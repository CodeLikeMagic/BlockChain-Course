As we discussed before, some of the main components of the Ethereum block are the header, the transactions, including the transaction hash or the transaction root, and the state radio booth, the state hash, or the state root. Integrity of the block is managed by assuring that the block header contents are not tampered with, the transactions are not tempered with, state transitions are efficiently computed, hashed, and verified. Remember, the block chain is supposed to be an immutable record. In Ethereum, the block hash is the block of all the elements in the block header, including the transaction root and state root hashes. It is computed by applying a variant of SHA-3 algorithm called Keccak and all the items of the block header. You would see a real example of bitcoin block hash in the quiz associated with this module. A typical block has about 2,000 transactions in bitcoin and about 100 transaction Ethereum. We need an efficient way to detect tampering and validate the transaction efficiently. Hashes of transaction in a block are processed in a tree structure called Mekle tree hash that we discussed in earlier lesson. Merkle tree hash is also used for computing the state root hash, since only the hash of the chained states from block to block have to be re-computed. It is also used for receipt hash root. Remember the advantage over flat versus tree representation. If any transaction is to be verified, only one path to the tree has to be checked. You don't have to go through the entire set of transactions. Smart contract execution in Ethereum results in state transitions. Every state change requires state root hash re-computation. Instead of computing hash for the entire set of states, only the affected path in the Merkle tree needs to be re-computed. When the state 19 is changed to 20, that results in the path including 31, 41, and the state root hash 64 to be re-computed. Only that path is re-computed, not the entire tree. Now, let's move on to block hash computation. Block hash in Ethereum is computed by first computing the state root hash, transaction root hash and then receipt root hash, shown at the bottom of the block header. These roots and all the other items in the header are hash together with the variable nodes to solve the proof of work puzzle. Block hash serves two important purposes; verification of the integrity of the block and the transactions, formation of the chain link by embedding the previous block hash in the current block header. If any participant node tampers with the block, it's hash value changes resulting in the mismatch of the hash values and rendering the local chain of the node in an invalid state. Any future blocks initiated by the node would be rejected by other miners due to hash mismatch. This enforces the immutability of the chain. Summarizing, a combination of hashing and encryption are used for securing the various elements of the block chain. Private public key pair and hashing are important foundational concepts in decentralized networks that operate beyond trust boundaries.